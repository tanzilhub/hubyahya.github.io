<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Debezium Connector for MongoDB :: Debezium Documentation</title>
    <link rel="canonical" href="https://www.debezium.io/documentation/reference/stable/connectors/mongodb.html">
    <meta name="generator" content="Antora 3.0.0-alpha.9">
<link rel="stylesheet" href="../../../debezium-antora/css/site.css">
<link rel="stylesheet" href="../../../debezium-antora/css/debezium-antora.css">
<link rel="stylesheet" href="../../../debezium-antora/css/highlightjs-dark.css">
<link rel="stylesheet" href="https://static.jboss.org/css/rhbar.css">
<script src="//static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.js"></script>
<script src="../../../debezium-antora/js/jquery.ba-floatingscrollbar.js"></script>
</head>
<body class="article">
<header class="header">
  <div id="rhbar">
      <a class="jbdevlogo" href="https://developers.redhat.com"></a>
      <a class="rhlogo" href="https://www.redhat.com"></a>
  </div>
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
          <img src="/assets/images/color_white_debezium_type_600px.svg" style="height: 32px; margin-right: 14px;"/>
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="/documentation/faq">FAQ</a>
        <a class="navbar-item" href="/documentation">DOCUMENTATION</a>
        <a class="navbar-item" href="/releases">RELEASES</a>
        <a class="navbar-item" href="/community">COMMUNITY</a>
        <a class="navbar-item" href="/blog">BLOG</a>
      </div>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="reference" data-version="1.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Debezium Documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Getting Started</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../tutorial.html">Tutorial</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../install.html">Installation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../postgres-plugins.html">PostgreSQL Decoding Plugins</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../features.html">Features</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/avro.html">Avro Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/topic-routing.html">Topic Routing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/event-flattening.html">New Record State Extraction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/mongodb-event-flattening.html">MongoDB New Document State Extraction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/outbox-event-router.html">Outbox Event Router</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Connectors</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mysql.html">MySQL</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="mongodb.html">MongoDB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="postgresql.html">PostgreSQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="oracle.html">Oracle</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="sqlserver.html">SQL Server</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="db2.html">Db2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="cassandra.html">Cassandra</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">API and SPI</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../development/engine.html">Debezium Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../development/converters.html">Custom Converters</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integrations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/serdes.html">Change Event SerDes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/outbox.html">Outbox Quarkus Extension</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/cloudevents.html">CloudEvents</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/testcontainers.html">Integration Testing with Testcontainers</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Operations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/monitoring.html">Monitoring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/openshift.html">Running on Openshift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/embedded.html">Embedding Debezium</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Debezium Documentation</span>
    <span class="version">1.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Debezium Documentation</span>
      <ul class="versions">
        <li class="version">
          <a href="../../index.html">nightly</a>
        </li>
        <li class="version">
          <a href="../../dev/index.html">dev</a>
        </li>
        <li class="version">
          <a href="../../stable/index.html">stable</a>
        </li>
        <li class="version">
          <a href="../../1.5/index.html">1.5</a>
        </li>
        <li class="version">
          <a href="../../1.4/index.html">1.4</a>
        </li>
        <li class="version">
          <a href="../../1.3/index.html">1.3</a>
        </li>
        <li class="version">
          <a href="../../1.2/index.html">1.2</a>
        </li>
        <li class="version is-current">
          <a href="../index.html">1.1</a>
        </li>
        <li class="version">
          <a href="../../1.0/index.html">1.0</a>
        </li>
        <li class="version">
          <a href="../../0.10/index.html">0.10</a>
        </li>
        <li class="version">
          <a href="../../0.9/index.html">0.9</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main role="main" class="main">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../stable/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Debezium Documentation</a></li>
    <li>Connectors</li>
    <li><a href="mongodb.html">MongoDB</a></li>
  </ul>
</nav>
    <div class="page-versions-container">
    Version:
    <div class="page-versions">
        <button class="version-menu-toggle versions-menu-current" title="Show other versions of page">1.1</button>
        <!--<button class="version-menu-toggle versions-menu-select" title="Select other versions">Select</button>-->
        <div class="version-menu">
                <a class="version" href="../../connectors/mongodb.html">nightly</a>
                <a class="version" href="../../dev/connectors/mongodb.html">dev</a>
                <a class="version" href="../../stable/connectors/mongodb.html">stable</a>
                <a class="version" href="../../1.5/connectors/mongodb.html">1.5</a>
                <a class="version" href="../../1.4/connectors/mongodb.html">1.4</a>
                <a class="version" href="../../1.3/connectors/mongodb.html">1.3</a>
                <a class="version" href="../../1.2/connectors/mongodb.html">1.2</a>
                <a class="version is-current" href="mongodb.html">1.1</a>
                <a class="version" href="../../1.0/connectors/mongodb.html">1.0</a>
                <a class="version" href="../../0.10/connectors/mongodb.html">0.10</a>
                <a class="version" href="../../0.9/connectors/mongodb.html">0.9</a>
        </div>
        |
    </div>
    </div>
  <div class="edit-this-page"><a href="https://github.com/uidoyen/debezium/edit/1.1/documentation/modules/ROOT/pages/connectors/mongodb.adoc">Edit this Page</a></div>
  </div>
<div class="article-grid">
<div class="article-cell1">
<article class="doc">
        
    <div class="version-banner version-banner-outdated">
    You are viewing documentation for an outdated version of Debezium.
    <br/>
</div>            <h1 class="page">Debezium Connector for MongoDB</h1>
        <div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#mongodb-overview">Overview</a></li>
<li><a href="#setting-up-mongodb">Setting up MongoDB</a></li>
<li><a href="#supported-mongodb-topologies">Supported MongoDB topologies</a>
<ul class="sectlevel2">
<li><a href="#mongodb-replicaset">MongoDB replica set</a></li>
<li><a href="#mongodb-sharded-cluster">MongoDB sharded cluster</a></li>
<li><a href="#mongodb-standalone-server">MongoDB standalone server</a></li>
</ul>
</li>
<li><a href="#how-the-mongodb-connector-works">How the MongoDB connector works</a>
<ul class="sectlevel2">
<li><a href="#mongodb-logical-connector-name">Logical connector name</a></li>
<li><a href="#mongodb-performing-a-snapshot">Performing a snapshot</a></li>
<li><a href="#mongodb-streaming-changes">Streaming changes</a></li>
<li><a href="#mongodb-topic-names">Topics names</a></li>
<li><a href="#mongodb-partitions">Partitions</a></li>
<li><a href="#mongodb-events">Events</a></li>
<li><a href="#mongodb-transaction-metadata">Transaction Metadata</a></li>
</ul>
</li>
<li><a href="#mongodb-deploying-a-connector">Deploying the MongoDB connector</a>
<ul class="sectlevel2">
<li><a href="#mongodb-example-configuration">Example configuration</a></li>
<li><a href="#mongodb-monitoring">Monitoring</a></li>
<li><a href="#mongodb-connector-properties">Connector properties</a></li>
</ul>
</li>
<li><a href="#mongodb-when-things-go-wrong">MongoDB connector common issues</a>
<ul class="sectlevel2">
<li><a href="#_configuration_and_startup_errors">Configuration and startup errors</a></li>
<li><a href="#_mongodb_becomes_unavailable">MongoDB becomes unavailable</a></li>
<li><a href="#_kafka_connect_process_stops_gracefully">Kafka Connect process stops gracefully</a></li>
<li><a href="#_kafka_connect_process_crashes">Kafka Connect process crashes</a></li>
<li><a href="#_kafka_becomes_unavailable">Kafka becomes unavailable</a></li>
<li><a href="#_connector_is_stopped_for_a_duration">Connector is stopped for a duration</a></li>
<li><a href="#_mongodb_loses_writes">MongoDB loses writes</a></li>
</ul>
</li>
</ul>
</div>
<div class="paragraph">
<p>Debezium&#8217;s MongoDB connector tracks a MongoDB replica set or a MongoDB sharded cluster for document changes in databases and collections, recording those changes as events in Kafka topics.
The connector automatically handles the addition or removal of shards in a sharded cluster, changes in membership of each replica set, elections within each replica set, and awaiting the resolution of communications problems.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mongodb-overview"><a class="anchor" href="#mongodb-overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB&#8217;s replication mechanism provides redundancy and high availability, and is the preferred way to run MongoDB in production.
MongoDB connector captures the changes in a replica set or sharded cluster.</p>
</div>
<div class="paragraph">
<p>A MongoDB <em>replica set</em> consists of a set of servers that all have copies of the same data, and replication ensures that all changes made by clients to documents on the replica set&#8217;s <em>primary</em> are correctly applied to the other replica set&#8217;s servers, called <em>secondaries</em>.
MongoDB replication works by having the primary record the changes in its <em>oplog</em> (or operation log), and then each of the secondaries reads the primary&#8217;s oplog and applies in order all of the operations to their own documents.
When a new server is added to a replica set, that server first performs an <a href="https://docs.mongodb.com/manual/core/replica-set-sync/">snapshot</a> of all of the databases and collections on the primary, and then reads the primary&#8217;s oplog to apply all changes that might have been made since it began the snapshot.
This new server becomes a secondary (and able to handle queries) when it catches up to the tail of the primary&#8217;s oplog.</p>
</div>
<div class="paragraph">
<p>The MongoDB connector uses this same replication mechanism, though it does not actually become a member of the replica set.
Just like MongoDB secondaries, however, the connector always reads the oplog of the replica set&#8217;s primary.
And, when the connector sees a replica set for the first time, it looks at the oplog to get the last recorded transaction and then performs a snapshot of the primary&#8217;s databases and collections.
When all the data is copied, the connector then starts streaming changes from the position it read earlier from the oplog. Operations in the MongoDB oplog are <a href="https://docs.mongodb.com/manual/core/replica-set-oplog/">idempotent</a>, so no matter how many times the operations are applied, they result in the same end state.</p>
</div>
<div class="paragraph">
<p>As the MongoDB connector processes changes, it periodically records the position in the oplog where the event originated.
When the MongoDB connector stops, it records the last oplog position that it processed, so that upon restart it simply begins streaming from that position.
In other words, the connector can be stopped, upgraded or maintained, and restarted some time later, and it will pick up exactly where it left off without losing a single event.
Of course, MongoDB&#8217;s oplogs are usually capped at a maximum size, which means that the connector should not be stopped for too long, or else some of the operations in the oplog might be purged before the connector has a chance to read them.
In this case, upon restart the connector will detect the missing oplog operations, perform a snapshot, and then proceed with streaming the changes.</p>
</div>
<div class="paragraph">
<p>The MongoDB connector is also quite tolerant of changes in membership and leadership of the replica sets, of additions or removals of shards within a sharded cluster, and network problems that might cause communication failures.
The connector always uses the replica set&#8217;s primary node to stream changes, so when the replica set undergoes an election and a different node becomes primary, the connector will immediately stop streaming changes, connect to the new primary, and start streaming changes using the new primary node.
Likewise, if connector experiences any problems communicating with the replica set primary, it will try to reconnect (using exponential backoff so as to not overwhelm the network or replica set) and continue streaming changes from where it last left off.
In this way the connector is able to dynamically adjust to changes in replica set membership and to automatically handle communication failures.</p>
</div>
<div class="ulist">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://docs.mongodb.com/manual/replication/">Replication mechanism</a></p>
</li>
<li>
<p><a href="https://docs.mongodb.com/manual/tutorial/deploy-replica-set/">Replica set</a></p>
</li>
<li>
<p><a href="https://docs.mongodb.com/manual/core/replica-set-elections/">Replica set elections</a></p>
</li>
<li>
<p><a href="https://docs.mongodb.com/manual/core/sharded-cluster-components/">Sharded cluster</a></p>
</li>
<li>
<p><a href="https://docs.mongodb.com/manual/tutorial/add-shards-to-shard-cluster/">Shard addition</a></p>
</li>
<li>
<p><a href="https://docs.mongodb.com/manual/tutorial/remove-shards-from-cluster/">Shard removal</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-mongodb"><a class="anchor" href="#setting-up-mongodb"></a>Setting up MongoDB</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The MongoDB connector uses MongoDB&#8217;s oplog to capture the changes, so the connector works only with MongoDB replica sets or with sharded clusters where each shard is a separate replica set.
See the MongoDB documentation for setting up a <a href="https://docs.mongodb.com/manual/replication/">replica set</a> or <a href="https://docs.mongodb.com/manual/sharding/">sharded cluster</a>.
Also, be sure to understand how to enable <a href="https://docs.mongodb.com/manual/tutorial/deploy-replica-set-with-keyfile-access-control/#deploy-repl-set-with-auth">access control and authentication</a> with replica sets.</p>
</div>
<div class="paragraph">
<p>You must also have a MongoDB user that has the appropriate roles to read the <code>admin</code> database where the oplog can be read. Additionally, the user must also be able to read the <code>config</code> database in the configuration server of a sharded cluster and must have <code>listDatabases</code> privilege action.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="supported-mongodb-topologies"><a class="anchor" href="#supported-mongodb-topologies"></a>Supported MongoDB topologies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The MongoDB connector can be used with a variety of MongoDB topologies.</p>
</div>
<div class="sect2">
<h3 id="mongodb-replicaset"><a class="anchor" href="#mongodb-replicaset"></a>MongoDB replica set</h3>
<div class="paragraph">
<p>The MongoDB connector can capture changes from a single <a href="https://docs.mongodb.com/manual/replication/">MongoDB replica set</a>.
Production replica sets require a minimum of <a href="https://docs.mongodb.com/manual/core/replica-set-architecture-three-members/">at least three members</a>.</p>
</div>
<div class="paragraph">
<p>To use the MongoDB connector with a replica set, provide the addresses of one or more replica set servers as <em>seed addresses</em> through the connector&#8217;s <code>mongodb.hosts</code> property.
The connector will use these seeds to connect to the replica set, and then once connected will get from the replica set the complete set of members and which member is primary.
The connector will start a task to connect to the primary and capture the changes from the primary&#8217;s oplog.
When the replica set elects a new primary, the task will automatically switch over to the new primary.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When MongoDB is fronted by a proxy (such as with Docker on OS X or Windows), then when a client connects to the replica set and discovers the members, the MongoDB client will exclude the proxy as a valid member and will attempt and fail to connect directly to the members rather than go through the proxy.</p>
</div>
<div class="paragraph">
<p>In such a case, set the connector&#8217;s optional <code>mongodb.members.auto.discover</code> configuration property to <code>false</code> to instruct the connector to forgo membership discovery and instead simply use the first seed address (specified via the <code>mongodb.hosts</code> property) as the primary node.
This may work, but still make cause issues when election occurs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-sharded-cluster"><a class="anchor" href="#mongodb-sharded-cluster"></a>MongoDB sharded cluster</h3>
<div class="paragraph">
<p>A <a href="https://docs.mongodb.com/manual/sharding/">MongoDB sharded cluster</a> consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>One or more <em>shards</em>, each deployed as a replica set;</p>
</li>
<li>
<p>A separate replica set that acts as the cluster&#8217;s <em>configuration server</em></p>
</li>
<li>
<p>One or more <em>routers</em> (also called <code>mongos</code>) to which clients connect and that routes requests to the appropriate shards</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use the MongoDB connector with a sharded cluster, configure the connector with the host addresses of the <em>configuration server</em> replica set. When the connector connects to this replica set, it discovers that it is acting as the configuration server for a sharded cluster, discovers the information about each replica set used as a shard in the cluster, and will then start up a separate task to capture the changes from each replica set. If new shards are added to the cluster or existing shards removed, the connector will automatically adjust its tasks accordingly.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-standalone-server"><a class="anchor" href="#mongodb-standalone-server"></a>MongoDB standalone server</h3>
<div class="paragraph">
<p>The MongoDB connector is not capable of monitoring the changes of a standalone MongoDB server, since standalone servers do not have an oplog.
The connector will work if the standalone server is converted to a replica set with one member.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>MongoDB <a href="https://docs.mongodb.com/manual/core/replica-set-architectures/">does not recommend</a> running a standalone server in production.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-the-mongodb-connector-works"><a class="anchor" href="#how-the-mongodb-connector-works"></a>How the MongoDB connector works</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a MongoDB connector is configured and deployed, it starts by connecting to the MongoDB servers at the seed addresses, and determines the details about each of the available replica sets.
Since each replica set has its own independent oplog, the connector will try to use a separate task for each replica set.
The connector can limit the maximum number of tasks it will use, and if not enough tasks are available the connector will assign multiple replica sets to each task, although the task will still use a separate thread for each replica set.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When running the connector against a sharded cluster, use a value of <code>tasks.max</code> that is greater than the number of replica sets.
This will allow the connector to create one task for each replica set, and will let Kafka Connect coordinate, distribute, and manage the tasks across all of the available worker processes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mongodb-logical-connector-name"><a class="anchor" href="#mongodb-logical-connector-name"></a>Logical connector name</h3>
<div class="paragraph">
<p>The connector configuration property <code>mongodb.name</code> serves as a <em>logical name</em> for the MongoDB replica set or sharded cluster.
The connector uses the logical name in a number of ways: as the prefix for all topic names, and as a unique identifier when recording the oplog position of each replica set.</p>
</div>
<div class="paragraph">
<p>You should give each MongoDB connector a unique logical name that meaningfully describes the source MongoDB system.
We recommend logical names begin with an alphabetic or underscore character, and remaining characters that are alphanumeric or underscore.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-performing-a-snapshot"><a class="anchor" href="#mongodb-performing-a-snapshot"></a>Performing a snapshot</h3>
<div class="paragraph">
<p>When a task starts up using a replica set, it uses the connector&#8217;s logical name and the replica set name to find an <em>offset</em> that describes the position where the connector previously stopped reading changes.
If an offset can be found and it still exists in the oplog, then the task immediately proceeds with <a href="#mongodb-streaming-changes">streaming changes</a>, starting at the recorded offset position.</p>
</div>
<div class="paragraph">
<p>However, if no offset is found or if the oplog no longer contains that position, the task must first obtain the current state of the replica set contents by performing a <em>snapshot</em>.
This process starts by recording the current position of the oplog and recording that as the offset (along with a flag that denotes a snapshot has been started).
The task will then proceed to copy each collection, spawning as many threads as possible (up to the value of the <code>initial.sync.max.threads</code> configuration property) to perform this work in parallel.
The connector will record a separate <em>read event</em> for each document it sees, and that read event will contain the object&#8217;s identifier, the complete state of the object, and <em>source</em> information about the MongoDB replica set where the object was found.
The source information will also include a flag that denotes the event was produced during a snapshot.</p>
</div>
<div class="paragraph">
<p>This snapshot will continue until it has copied all collections that match the connector&#8217;s filters.
If the connector is stopped before the tasks' snapshots are completed, upon restart the connector begins the snapshot again.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Try to avoid task reassignment and reconfiguration while the connector is performing a snapshot of any replica sets. The connector does log messages with the progress of the snapshot. For utmost control, run a separate cluster of Kafka Connect for each connector.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-streaming-changes"><a class="anchor" href="#mongodb-streaming-changes"></a>Streaming changes</h3>
<div class="paragraph">
<p>Once the connector task for a replica set has an offset, it uses the offset to determine the position in the oplog where it should start streaming changes.
The task will then connect to the replica set&#8217;s primary node and start streaming changes from that position, processing all of the create, insert, and delete operations and converting them into Debezium <a href="#mongodb-events">change events</a>. Each change event includes the position in the oplog where the operation was found, and the connector periodically records this as its most recent offset. The interval at which the offset is recorded is governed by <a href="https://kafka.apache.org/documentation/#offset.flush.interval.ms"><code>offset.flush.interval.ms</code></a>, which is a Kafka Connect worker configuration property.</p>
</div>
<div class="paragraph">
<p>When the connector is stopped gracefully, the last offset processed is recorded so that, upon restart, the connector will continue exactly where it left off.
If the connector&#8217;s tasks terminate unexpectedly, however, then the tasks may have processed and generated events after it last records the offset but before the last offset is recorded; upon restart, the connector begins at the last <em>recorded</em> offset, possibly generating some the same events that were previously generated just prior to the crash.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When everything is operating nominally, Kafka consumers will actually see every message <strong><em>exactly once</em></strong>. However, when things go wrong Kafka can only guarantee consumers will see every message <strong><em>at least once</em></strong>. Therefore, your consumers need to anticipate seeing messages more than once.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As mentioned above, the connector tasks always use the replica set&#8217;s primary node to stream changes from the oplog, ensuring that the connector sees the most up-to-date operations as possible and can capture the changes with lower latency than if secondaries were to be used instead. When the replica set elects a new primary, the connector immediately stops streaming changes, connects to the new primary, and starts streaming changes from the new primary node at the same position. Likewise, if the connector experiences any problems communicating with the replica set members, it trys to reconnect, by using exponential backoff so as to not overwhelm the replica set, and once connected it continues streaming changes from where it last left off. In this way, the connector is able to dynamically adjust to changes in replica set membership and automatically handle communication failures.</p>
</div>
<div class="paragraph">
<p>To summarize, the MongoDB connector continues running in most situations. Communication problems might cause the connector to wait until the problems are resolved.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-topic-names"><a class="anchor" href="#mongodb-topic-names"></a>Topics names</h3>
<div class="paragraph">
<p>The MongoDB connector writes events for all insert, update, and delete operations to documents in each collection to a single Kafka topic.
The name of the Kafka topics always takes the form <em>logicalName</em>.<em>databaseName</em>.<em>collectionName</em>, where <em>logicalName</em> is the <a href="#mongodb-logical-connector-name">logical name</a> of the connector as specified with the <code>mongodb.name</code> configuration property, <em>databaseName</em> is the name of the database where the operation occurred, and <em>collectionName</em> is the name of the MongoDB collection in which the affected document existed.</p>
</div>
<div class="paragraph">
<p>For example, consider a MongoDB replica set with an <code>inventory</code> database that contains four collections: <code>products</code>, <code>products_on_hand</code>, <code>customers</code>, and <code>orders</code>.
If the connector monitoring this database were given a logical name of <code>fulfillment</code>, then the connector would produce events on these four Kafka topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fulfillment.inventory.products</code></p>
</li>
<li>
<p><code>fulfillment.inventory.products_on_hand</code></p>
</li>
<li>
<p><code>fulfillment.inventory.customers</code></p>
</li>
<li>
<p><code>fulfillment.inventory.orders</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that the topic names do not incorporate the replica set name or shard name.
As a result, all changes to a sharded collection (where each shard contains a subset of the collection&#8217;s documents) all go to the same Kafka topic.</p>
</div>
<div class="paragraph">
<p>You can set up Kafka to <a href="https://kafka.apache.org/documentation.html#basic_ops_add_topic">auto-create</a> the topics as they are needed.
If not, then you must use Kafka administration tools to create the topics before starting the connector.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-partitions"><a class="anchor" href="#mongodb-partitions"></a>Partitions</h3>
<div class="paragraph">
<p>The MongoDB connector does not make any explicit determination of the topic partitions for events.
Instead, it allows Kafka to determine the partition based on the key.
You can change Kafka&#8217;s partitioning logic by defining in the Kafka Connect worker configuration the name of the <code>Partitioner</code> implementation.</p>
</div>
<div class="paragraph">
<p>Kafka maintains total order only for events written to a single topic partition.
Partitioning the events by key does mean that all events with the same key always go to the same partition. This ensures that all events for a specific document are always totally ordered.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-events"><a class="anchor" href="#mongodb-events"></a>Events</h3>
<div class="paragraph">
<p>All data change events produced by the MongoDB connector have a key and a value.</p>
</div>
<div class="paragraph">
<p>Debezium and Kafka Connect are designed around <em>continuous streams of event messages</em>, and the structure of these events could potentially change over time if the source of those events changed in structure or if the connector is improved or changed.
This could be difficult for consumers to deal with, so to make it very easy Kafka Connect makes each event self-contained. Every message key and value has two parts: a <em>schema</em> and <em>payload</em>. The schema describes the structure of the payload, while the payload contains the actual data.</p>
</div>
<div class="sect3">
<h4 id="mongodb-change-events-key"><a class="anchor" href="#mongodb-change-events-key"></a>Change event&#8217;s key</h4>
<div class="paragraph">
<p>For a given collection, the change event&#8217;s key contains a single <code>id</code> field.
Its value is the document&#8217;s identifier represented as string which is derived from the <a href="https://docs.mongodb.com/manual/reference/mongodb-extended-json/">MongoDB extended JSON serialization in strict mode</a>. Consider a connector with a logical name of <code>fulfillment</code>, a replica set containing an <code>inventory</code> database with a <code>customers</code> collection containing documents such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "_id": 1004,
  "first_name": "Anne",
  "last_name": "Kretchmar",
  "email": "annek@noanswer.org"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every change event for the <code>customers</code> collection will feature the same key structure, which in JSON looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": {
    "type": "struct",
    "name": "fulfillment.inventory.customers.Key"
    "optional": false,
    "fields": [
      {
        "field": "id",
        "type": "string",
        "optional": false
      }
    ]
  },
  "payload": {
    "id": "1004"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>schema</code> portion of the key contains a Kafka Connect schema describing what is in the payload portion. In this case, it means that the <code>payload</code> value is not optional, is a structure defined by a schema named <code>fulfillment.inventory.customers.Key</code>, and has one required field named <code>id</code> of type <code>string</code>. If you look at the value of the key&#8217;s <code>payload</code> field, you can see that it is indeed a structure (which in JSON is just an object) with a single <code>id</code> field, whose value is a string containing the integer <code>1004</code>.</p>
</div>
<div class="paragraph">
<p>This example used a document with an integer identifier, but any valid MongoDB document identifier (including documents) will work. The value of the <code>id</code> field in the payload will simply be a string representing a MongoDB extended JSON serialization (strict mode) of the original document&#8217;s <code>_id</code> field. Find below a few examples showing how <code>_id</code> fields of
different types will get encoded as the event key&#8217;s payload:</p>
</div>
<table class="tableblock frame-all grid-all stretch code-wordbreak-col2 code-wordbreak-col3">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">MongoDB <code>_id</code> Value</th>
<th class="tableblock halign-left valign-top">Key&#8217;s payload</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1234</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "1234" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.34</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "12.34" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"1234"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "\"1234\"" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Document</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ "hi" : "kafka", "nums" : [10.0, 100.0, 1000.0] }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "{\"hi\" : \"kafka\", \"nums\" : [10.0, 100.0, 1000.0]}" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectId("596e275826f08b2730779e1f")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "{\"$oid\" : \"596e275826f08b2730779e1f\"}" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BinData("a2Fma2E=",0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "id" : "{\"$binary\" : \"a2Fma2E=\", \"$type\" : \"00\"}" }</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MongoDB connector ensures that all Kafka Connect <em>schema names</em> are <a href="http://avro.apache.org/docs/current/spec.html#names">valid Avro schema names</a>. This means that the logical server name must start with Latin letters or an underscore (e.g., [a-z,A-Z,_]), and the remaining characters in the logical server name and all characters in the database and collections names must be Latin letters, digits, or an underscore (e.g., [a-z,A-Z,0-9,\_]). If not, then all invalid characters will automatically be replaced with an underscore character.</p>
</div>
<div class="paragraph">
<p>This can lead to unexpected conflicts in schemas names when the logical server name, database names, and collection names contain other characters, and the only distinguishing characters between collection full names are invalid and thus replaced with underscores. The connector attempts to produce an exception in this such cases, but only when the conflicts exist between schemas used within a single connector.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mongodb-change-events-value"><a class="anchor" href="#mongodb-change-events-value"></a>Change event&#8217;s value</h4>
<div class="paragraph">
<p>The value of the change event message is a bit more complicated.
Like the key message, it has a <em>schema</em> section and <em>payload</em> section.
The payload section of every change event value produced by the MongoDB connector has an <em>envelope</em> structure with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>op</code> is a mandatory field that contains a string value describing the type of operation. Values for the MongoDB connector are <code>c</code> for create (or insert), <code>u</code> for update, <code>d</code> for delete, and <code>r</code> for read (in the case of a snapshot).</p>
</li>
<li>
<p><code>after</code> is an optional field that if present contains the state of the document <em>after</em> the event occurred. MongoDB&#8217;s oplog entries only contain the full state of a document for <em>create</em> events, so these are the only events that contain an <em>after</em> field.</p>
</li>
<li>
<p><code>source</code> is a mandatory field that contains a structure describing the source metadata for the event, which in the case of MongoDB contains several fields: the Debezium version, the logical name, the replica set&#8217;s name, the namespace of the collection, the MongoDB timestamp (and ordinal of the event within the timestamp) at which the event occurred, the identifier of the MongoDB operation (e.g., the <code>h</code> field in the oplog event), and the initial sync flag if the event resulted during a snapshot.</p>
</li>
<li>
<p><code>ts_ms</code> is optional and if present contains the time (using the system clock in the JVM running the Kafka Connect task) at which the connector processed the event.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And of course, the <em>schema</em> portion of the event message&#8217;s value contains a schema that describes this envelope structure and the nested fields within it.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at what a <em>create</em>/<em>read</em> event value might look like for our <code>customers</code> collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "schema": {
      "type": "struct",
      "fields": [
        {
          "type": "string",
          "optional": true,
          "name": "io.debezium.data.Json",
          "version": 1,
          "field": "after"
        },
        {
          "type": "string",
          "optional": true,
          "name": "io.debezium.data.Json",
          "version": 1,
          "field": "patch"
        },
        {
          "type": "string",
          "optional": true,
          "name": "io.debezium.data.Json",
          "version": 1,
          "field": "filter"
        },
        {
          "type": "struct",
          "fields": [
            {
              "type": "string",
              "optional": false,
              "field": "version"
            },
            {
              "type": "string",
              "optional": false,
              "field": "connector"
            },
            {
              "type": "string",
              "optional": false,
              "field": "name"
            },
            {
              "type": "int64",
              "optional": false,
              "field": "ts_ms"
            },
            {
              "type": "boolean",
              "optional": true,
              "default": false,
              "field": "snapshot"
            },
            {
              "type": "string",
              "optional": false,
              "field": "db"
            },
            {
              "type": "string",
              "optional": false,
              "field": "rs"
            },
            {
              "type": "string",
              "optional": false,
              "field": "collection"
            },
            {
              "type": "int32",
              "optional": false,
              "field": "ord"
            },
            {
              "type": "int64",
              "optional": true,
              "field": "h"
            }
          ],
          "optional": false,
          "name": "io.debezium.connector.mongo.Source",
          "field": "source"
        },
        {
          "type": "string",
          "optional": true,
          "field": "op"
        },
        {
          "type": "int64",
          "optional": true,
          "field": "ts_ms"
        }
      ],
      "optional": false,
      "name": "dbserver1.inventory.customers.Envelope"
      },
    "payload": {
      "after": "{\"_id\" : {\"$numberLong\" : \"1004\"},\"first_name\" : \"Anne\",\"last_name\" : \"Kretchmar\",\"email\" : \"annek@noanswer.org\"}",
      "patch": null,
      "source": {
        "version": "1.1.2.Final",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "snapshot": true,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 31,
        "h": 1546547425148721999
      },
      "op": "r",
      "ts_ms": 1558965515240
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we look at the <code>schema</code> portion of this event&#8217;s <em>value</em>, we can see the schema for the <em>envelope</em> is specific to the collection, and the schema for the <code>source</code> structure (which is specific to the MongoDB connector and reused across all events). Also note that the <code>after</code> value is always a string, and that by convention it will contain a JSON representation of the document.</p>
</div>
<div class="paragraph">
<p>If we look at the <code>payload</code> portion of this event&#8217;s <em>value</em>, we can see the information in the event, namely that it is describing that the document was read as part of an snapshot (since <code>op=r</code> and <code>snapshot=true</code>), and that the <code>after</code> field value contains the JSON string representation of the document.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It may appear that the JSON representations of the events are much larger than the rows they describe. This is true, because the JSON representation must include the <em>schema</em> and the <em>payload</em> portions of the message.
It is possible and even recommended to use the <a href="/docs/faq/#avro-converter">Avro Converter</a> to dramatically decrease the size of the actual messages written to the Kafka topics.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The value of an <em>update</em> change event on this collection will actually have the exact same <em>schema</em>, and its payload is structured the same but will hold different values. Specifically, an update event will not have an <code>after</code> value and will instead have a <code>patch</code> string containing the JSON representation of the idempotent update operation and a <code>filter</code> string containing the JSON representation of the selection criteria for the update.  The <code>filter</code> string can include multiple shard key fields for sharded collections. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "schema": { ... },
    "payload": {
      "op": "u",
      "ts_ms": 1465491461815,
      "patch": "{\"$set\":{\"first_name\":\"Anne Marie\"}}",
      "filter": "{\"_id\" : {\"$numberLong\" : \"1004\"}}",
      "source": {
        "version": "1.1.2.Final",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "snapshot": true,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 6,
        "h": 1546547425148721999
      }
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compare this to the value in the <em>insert</em> event, we see a couple of differences in the <code>payload</code> section:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>op</code> field value is now <code>u</code>, signifying that this document changed because of an update</p>
</li>
<li>
<p>The <code>patch</code> field appears and has the stringified JSON representation of the actual MongoDB idempotent change to the document, which in this example involves setting the <code>first_name</code> field to a new value</p>
</li>
<li>
<p>The <code>filter</code> field appears and has the stringified JSON representation of the MongoDB selection criteria used for the update</p>
</li>
<li>
<p>The <code>after</code> field no longer appears</p>
</li>
<li>
<p>The <code>source</code> field structure has the same fields as before, but the values are different since this event is from a different position in the oplog</p>
</li>
<li>
<p>The <code>ts_ms</code> shows the timestamp that Debezium processed this event</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The content of the patch field is provided by MongoDB itself and its exact format depends on the specific database version.
You should therefore be prepared for potential changes to the format when upgrading the MongoDB instance to a new version.</p>
</div>
<div class="paragraph">
<p>All examples in this document were obtained from MongoDB 3.4 and might differ if you use a different one.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Update events in MongoDB&#8217;s oplog do not have the <em>before</em> or <em>after</em> states of the changed document, so there&#8217;s no way for the connector to provide this information.
However, because <em>create</em> or <em>read</em> events <em>do</em> contain the starting state, downstream consumers of the stream can actually fully-reconstruct the state by keeping the latest state for each document and applying each event to that state. Debezium connector&#8217;s are not able to keep such state, so it is not able to do this.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So far, you have seen samples of <em>create</em>/<em>read</em> and <em>update</em> events. The following sample shows the value of a <em>delete</em> event for the same collection.
The value of a <em>delete</em> event on this collection has the exact same <em>schema</em>, and its payload is structured the same but it holds different values.
In particular, a delete event does not have an <code>after</code> value nor a <code>patch</code> value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "schema": { ... },
    "payload": {
      "op": "d",
      "ts_ms": 1465495462115,
      "filter": "{\"_id\" : {\"$numberLong\" : \"1004\"}}",
      "source": {
        "version": "1.1.2.Final",
        "connector": "mongodb",
        "name": "fulfillment",
        "ts_ms": 1558965508000,
        "snapshot": true,
        "db": "inventory",
        "rs": "rs0",
        "collection": "customers",
        "ord": 6,
        "h": 1546547425148721999
      }
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compare this to the value in the other events, we see a couple of differences in the <code>payload</code> section:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>op</code> field value is now <code>d</code>, signifying that this document was deleted</p>
</li>
<li>
<p>The <code>patch</code> field does not appear</p>
</li>
<li>
<p>The <code>after</code> field does not appear</p>
</li>
<li>
<p>The <code>filter</code> field appears and has the stringified JSON representation of the MongoDB selection criteria used for the delete</p>
</li>
<li>
<p>The <code>source</code> field structure has the same fields as before, but the values are different since this event is from a different position in the oplog</p>
</li>
<li>
<p>The <code>ts_ms</code> shows the timestamp that Debezium processed this event</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The MongoDB connector provides one other kind of event. Each <em>delete</em> event is followed by a <em>tombstone</em> event that has the same key as the <em>delete</em> event but a <code>null</code> value. This provides Kafka with the information needed to run its <a href="https://kafka.apache.org/documentation/#compaction">log compaction</a> mechanism to remove <em>all</em> messages with that key.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All MongoDB connector events are designed to work with <a href="https://kafka.apache.org/documentation/#compaction">Kafka log compaction</a>, which allows for the removal of older messages as long as at least the most recent message for every key is kept. This is how Kafka can reclaim storage space while ensuring that the topic contains a complete dataset and can be used for reloading key-based state.</p>
</div>
<div class="paragraph">
<p>All MongoDB connector events for a uniquely identified document have exactly the same key, signaling to Kafka that only the latest event be kept. A tombstone event informs Kafka that <em>all</em> messages with that same key can be removed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-transaction-metadata"><a class="anchor" href="#mongodb-transaction-metadata"></a>Transaction Metadata</h3>
<div class="paragraph">
<p>Debezium can generate events that represents tranaction metadata boundaries and enrich data messages.</p>
</div>
<div class="sect3">
<h4 id="_transaction_boundaries"><a class="anchor" href="#_transaction_boundaries"></a>Transaction boundaries</h4>
<div class="paragraph">
<p>Debezium generates events for every transaction <code>BEGIN</code> and <code>END</code>.
Every event contains</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>status</code> - <code>BEGIN</code> or <code>END</code></p>
</li>
<li>
<p><code>id</code> - string representation of unique transaction identifier</p>
</li>
<li>
<p><code>event_count</code> (for <code>END</code> events) - total number of events emmitted by the transaction</p>
</li>
<li>
<p><code>data_collections</code> (for <code>END</code> events) - an array of pairs of <code>data_collection</code> and <code>event_count</code> that provides number of events emitted by changes originating from given data collection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an example of what a message looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "rs0.testDB.tablea",
      "event_count": 1
    },
    {
      "data_collection": "rs0.testDB.tableb",
      "event_count": 1
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transaction events are written to the topic named <code>&lt;database.server.name&gt;.transaction</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_data_events_enrichment"><a class="anchor" href="#_data_events_enrichment"></a>Data events enrichment</h4>
<div class="paragraph">
<p>When transaction metadata is enabled the data message <code>Envelope</code> is enriched with a new <code>transaction</code> field.
This field provides information about every event in the form of a composite of fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> - string representation of unique transaction identifier</p>
</li>
<li>
<p><code>total_order</code> - the absolute position of the event among all events generated by the transaction</p>
</li>
<li>
<p><code>data_collection_order</code> - the per-data collection position of the event among all events that were emitted by the transaction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an example of what a message looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mongodb-deploying-a-connector"><a class="anchor" href="#mongodb-deploying-a-connector"></a>Deploying the MongoDB connector</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you have already installed <a href="https://zookeeper.apache.org">Zookeeper</a>, <a href="http://kafka.apache.org/">Kafka</a>, and <a href="https://kafka.apache.org/documentation.html#connect">Kafka Connect</a>, then using Debezium&#8217;s MongoDB connector is easy.
Simply download the
<a href="https://repo1.maven.org/maven2/io/debezium/debezium-connector-mongodb/1.1.2.Final/debezium-connector-mongodb-1.1.2.Final-plugin.tar.gz">connector&#8217;s plug-in archive</a>,
extract the JARs into your Kafka Connect environment, and add the directory with the JARs to Kafka Connect&#8217;s <code>plugin.path</code> by using the <a href="https://kafka.apache.org/documentation/#connectconfigs">plugin.path</a> configuration property.
Restart your Kafka Connect process to pick up the new JARs.</p>
</div>
<div class="paragraph">
<p>If immutable containers are your thing, then check out <a href="https://hub.docker.com/r/debezium/">Debezium&#8217;s Docker images</a> for Zookeeper, Kafka, and Kafka Connect with the MongoDB connector already pre-installed and ready to go.
Our <a href="../tutorial.html" class="page">tutorial</a> even walks you through using these images, and this is a great way to learn what Debezium is all about. You can even <a href="/blog/2016/05/31/Debezium-on-Kubernetes/">run Debezium on Kubernetes and OpenShift</a>.</p>
</div>
<div class="sect2">
<h3 id="mongodb-example-configuration"><a class="anchor" href="#mongodb-example-configuration"></a>Example configuration</h3>
<div class="paragraph">
<p>To use the connector to produce change events for a particular MongoDB replica set or sharded cluster, create a configuration file in JSON.
When the connector starts, it will perform a snapshot of the collections in your MongoDB replica sets and start reading the replica sets' oplogs, producing events for every inserted, updated, and deleted row.
Optionally filter out collections that are not needed.</p>
</div>
<div class="paragraph">
<p>Following is an example of the configuration for a MongoDB connector that monitors a MongoDB replica set <code>rs0</code> at port 27017 on 192.168.99.100, which we logically name <code>fullfillment</code>.
Typically, you configure the Debezium MongoDB connector in a <code>.json</code> file using the configuration properties available for the connector.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "inventory-connector",  <i class="conum" data-value="1"></i><b>(1)</b>
  "config": {
    "connector.class": "io.debezium.connector.mongodb.MongoDbConnector", <i class="conum" data-value="2"></i><b>(2)</b>
    "mongodb.hosts": "rs0/192.168.99.100:27017", <i class="conum" data-value="3"></i><b>(3)</b>
    "mongodb.name": "fullfillment", <i class="conum" data-value="4"></i><b>(4)</b>
    "collection.whitelist": "inventory[.]*", <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The name of our connector when we register it with a Kafka Connect service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The name of the MongoDB connector class.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The host addresses to use to connect to the MongoDB replica set.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <em>logical name</em> of the MongoDB replica set, which forms a namespace for generated events and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the Avro Connector is used.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A list of regular expressions that match the collection namespaces (for example, &lt;dbName&gt;.&lt;collectionName&gt;) of all collections to be monitored. This is optional.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the <a href="#mongodb-connector-properties">complete list of connector properties</a> that can be specified in these configurations.</p>
</div>
<div class="paragraph">
<p>This configuration can be sent via POST to a running Kafka Connect service, which will then record the configuration and start up the one connector task that will connect to the MongoDB replica set or sharded cluster, assign tasks for each replica set, perform a snapshot if necessary, read the oplog, and record events to Kafka topics.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-monitoring"><a class="anchor" href="#mongodb-monitoring"></a>Monitoring</h3>
<div class="paragraph">
<p>The Debezium MongoDB connector has two metric types in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect have.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mongodb-snapshot-metrics">snapshot metrics</a>; for monitoring the connector when performing snapshots</p>
</li>
<li>
<p><a href="#mongodb-streaming-metrics">streaming metrics</a>; for monitoring the connector when processing oplog events</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please refer to the <a href="../operations/monitoring.html#monitoring-debezium" class="page">monitoring documentation</a> for details of how to expose these metrics via JMX.</p>
</div>
<div class="sect3">
<h4 id="mongodb-snapshot-metrics"><a class="anchor" href="#mongodb-snapshot-metrics"></a>Snapshot Metrics</h4>
<div class="paragraph">
<p>The <strong>MBean</strong> is <code>debezium.mongodb:type=connector-metrics,context=snapshot,server=<em>&lt;mongodb.name&gt;</em></code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Attribute Name</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Type</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>LastEvent</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The last snapshot event that the connector has read.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MilliSecondsSinceLastEvent</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of milliseconds since the connector has read and processed the most recent event.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TotalNumberOfEventsSeen</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The total number of events that this connector has seen since last started or reset.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NumberOfEventsFiltered</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of events that have been filtered by whitelist or blacklist filtering rules configured on the connector.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MonitoredTables</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string[]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The list of collections that are monitored by the connector.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>QueueTotalCapcity</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The length of the queue used to pass events between the snapshotter and the main Kafka Connect loop.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>QueueRemainingCapcity</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TotalTableCount</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The total number of collections that are being included in the snapshot.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>RemainingTableCount</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of collections that the snapshot has yet to copy.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SnapshotRunning</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Whether the snapshot was started.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SnapshotAborted</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Whether the snapshot was aborted.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SnapshotCompleted</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Whether the snapshot completed.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SnapshotDurationInSeconds</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The total number of seconds that the snapshot has taken so far, even if not complete.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>RowsScanned</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Map&lt;String, Long&gt;</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Map containing the number of documents exported for each collection in the snapshot. Collections are incrementally added to the Map during processing. Updates every 10,000 documents scanned and upon completing a collection.</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The Debezium MongoDB connector also provides the following custom snapshot metrics:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 20%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NumberOfDisconnects</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of database disconnects.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mongodb-streaming-metrics"><a class="anchor" href="#mongodb-streaming-metrics"></a>Streaming Metrics</h4>
<div class="paragraph">
<p>The <strong>MBean</strong> is <code>debezium.sql_server:type=connector-metrics,context=streaming,server=<em>&lt;mongodb.name&gt;</em></code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Attribute Name</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Type</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>LastEvent</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The last streaming event that the connector has read.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MilliSecondsSinceLastEvent</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of milliseconds since the connector has read and processed the most recent event.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TotalNumberOfEventsSeen</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The total number of events that this connector has seen since last started or reset.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NumberOfEventsFiltered</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of events that have been filtered by whitelist or blacklist filtering rules configured on the connector.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MonitoredTables</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string[]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The list of collections that are monitored by the connector.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>QueueTotalCapcity</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The length of the queue used to pass events between the streamer and the main Kafka Connect loop.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>QueueRemainingCapcity</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Connected</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Flag that denotes whether the connector is currently connected to mongodb.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MilliSecondsBehindSource</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of milliseconds between the last change event&#8217;s timestamp and the connector processing it. The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NumberOfCommittedTransactions</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The number of processed transactions that were committed.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SourceEventPosition</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>map&lt;string, string&gt;</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The coordinates of the last received event.</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>LastTransactionId</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Transaction identifier of the last processed transaction.</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The Debezium MongoDB connector also provides the following custom streaming metrics:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 20%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NumberOfDisconnects</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of database disconnects.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NumberOfPrimaryElections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of primary node elections.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-connector-properties"><a class="anchor" href="#mongodb-connector-properties"></a>Connector properties</h3>
<div class="paragraph">
<p>The following configuration properties are <em>required</em> unless a default value is available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-name"></a><a href="#mongodb-property-name"><code>name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-connector-class"></a><a href="#mongodb-property-connector-class"><code>connector.class</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the Java class for the connector. Always use a value of <code>io.debezium.connector.mongodb.MongoDbConnector</code> for the MongoDB connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-hosts"></a><a href="#mongodb-property-mongodb-hosts"><code>mongodb.hosts</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The comma-separated list of hostname and port pairs (in the form 'host' or 'host:port') of the MongoDB servers in the replica set. The list can contain a single hostname and port pair. If <code>mongodb.members.auto.discover</code> is set to <code>false</code>, then the host and port pair should be prefixed with the replica set name (e.g., <code>rs0/localhost:27017</code>).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-name"></a><a href="#mongodb-property-mongodb-name"><code>mongodb.name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A unique name that identifies the connector and/or MongoDB replica set or sharded cluster that this connector monitors. Each server should be monitored by at most one Debezium connector, since this server name prefixes all persisted Kafka topics emanating from the MongoDB replica set or cluster.
Only alphanumeric characters and underscores should be used.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-user"></a><a href="#mongodb-property-mongodb-user"><code>mongodb.user</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Name of the database user to be used when connecting to MongoDB. This is required only when MongoDB is configured to use authentication.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-password"></a><a href="#mongodb-property-mongodb-password"><code>mongodb.password</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Password to be used when connecting to MongoDB. This is required only when MongoDB is configured to use authentication.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-authsource"></a><a href="#mongodb-property-mongodb-authsource"><code>mongodb.authsource</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>admin</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Database (authentication source) containing MongoDB credentials. This is required only when MongoDB is configured to use authentication with another authentication database than <code>admin</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-ssl-enabled"></a><a href="#mongodb-property-mongodb-ssl-enabled"><code>mongodb.ssl.enabled</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Connector will use SSL to connect to MongoDB instances.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-ssl-invalid-hostname-allowed"></a><a href="#mongodb-property-mongodb-ssl-invalid-hostname-allowed"><code>mongodb.ssl.invalid.hostname.allowed</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When SSL is enabled this setting controls whether strict hostname checking is disabled during connection phase. If <code>true</code> the connection will not prevent man-in-the-middle attacks.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-database-whitelist"></a><a href="#mongodb-property-database-whitelist"><code>database.whitelist</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match database names to be monitored; any database name not included in the whitelist is excluded from monitoring. By default all databases is monitored.
May not be used with <code>database.blacklist</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-database-blacklist"></a><a href="#mongodb-property-database-blacklist"><code>database.blacklist</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match database names to be excluded from monitoring; any database name not included in the blacklist is monitored. May not be used with <code>database.whitelist</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-collection-whitelist"></a><a href="#mongodb-property-collection-whitelist"><code>collection.whitelist</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match fully-qualified namespaces for MongoDB collections to be monitored; any collection not included in the whitelist is excluded from monitoring. Each identifier is of the form <em>databaseName</em>.<em>collectionName</em>. By default the connector will monitor all collections except those in the <code>local</code> and <code>admin</code> databases. May not be used with <code>collection.blacklist</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-collection-blacklist"></a><a href="#mongodb-property-collection-blacklist"><code>collection.blacklist</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match fully-qualified namespaces for MongoDB collections to be excluded from monitoring; any collection not included in the blacklist is monitored. Each identifier is of the form <em>databaseName</em>.<em>collectionName</em>. May not be used with <code>collection.whitelist</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-snapshot-mode"></a><a href="#mongodb-property-snapshot-mode"><code>snapshot.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>initial</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the criteria for running a snapshot upon startup of the connector. The default is <strong>initial</strong>, and specifies the connector reads a snapshot when either no offset is found or if the oplog no longer contains the previous offset. The <strong>never</strong> option specifies that the connector should never use snapshots, instead the connector should proceed to tail the log.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-field-blacklist"></a><a href="#mongodb-property-field-blacklist"><code>field.blacklist</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of the fully-qualified names of fields that should be excluded from change event message values. Fully-qualified names for fields are of the form <em>databaseName</em>.<em>collectionName</em>.<em>fieldName</em>.<em>nestedFieldName</em>, where <em>databaseName</em> and <em>collectionName</em> may contain the wildcard (*) which matches any characters.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-field-renames"></a><a href="#mongodb-property-field-renames"><code>field.renames</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of the fully-qualified replacements of fields that should be used to rename fields in change event message values. Fully-qualified replacements for fields are of the form <em>databaseName</em>.<em>collectionName</em>.<em>fieldName</em>.<em>nestedFieldName</em>:<em>newNestedFieldName</em>, where <em>databaseName</em> and <em>collectionName</em> may contain the wildcard (*) which matches any characters, the colon character (:) is used to determine rename mapping of field. The next field replacement is applied to the result of the previous field replacement in the list, so keep this in mind when renaming multiple fields that are in the same path.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-tasks-max"></a><a href="#mongodb-property-tasks-max"><code>tasks.max</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of tasks that should be created for this connector. The MongoDB connector will attempt to use a separate task for each replica set, so the default is acceptable when using the connector with a single MongoDB replica set. When using the connector with a MongoDB sharded cluster, we recommend specifying a value that is equal to or more than the number of shards in the cluster, so that the work for each replica set can be distributed by Kafka Connect.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-initial-sync-max-threads"></a><a href="#mongodb-property-initial-sync-max-threads"><code>initial.sync.max.threads</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum number of threads used to perform an intial sync of the collections in a replica set. Defaults to 1.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-tombstones-on-delete"></a><a href="#mongodb-property-tombstones-on-delete"><code>tombstones.on.delete</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls whether a tombstone event should be generated after a delete event.<br>
When <code>true</code> the delete operations are represented by a delete event and a subsequent tombstone event. When <code>false</code> only a delete event is sent.<br>
Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-snapshot-delay-ms"></a><a href="#mongodb-property-snapshot-delay-ms"><code>snapshot.delay.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An interval in milli-seconds that the connector should wait before taking a snapshot after starting up;<br>
Can be used to avoid snapshot interruptions when starting multiple connectors in a cluster, which may cause re-balancing of connectors.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-snapshot-fetch-size"></a><a href="#mongodb-property-snapshot-fetch-size"><code>snapshot.fetch.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>0</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the maximum number of documents that should be read in one go from each collection while taking a snapshot.
The connector will read the collection contents in multiple batches of this size.<br>
Defaults to 0, which indicates that the server chooses an appropriate fetch size.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following <em>advanced</em> configuration properties have good defaults that will work in most situations and therefore rarely need to be specified in the connector&#8217;s configuration.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Property</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Description</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-max-queue-size"></a><a href="#mongodb-property-max-queue-size"><code>max.queue.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>8192</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the oplog reader when, for example, writes to Kafka are slower or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified in the <code>max.batch.size</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-max-batch-size"></a><a href="#mongodb-property-max-batch-size"><code>max.batch.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>2048</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-poll-interval-ms"></a><a href="#mongodb-property-poll-interval-ms"><code>poll.interval.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 1000 milliseconds, or 1 second.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-connect-backoff-initial-delay-ms"></a><a href="#mongodb-property-connect-backoff-initial-delay-ms"><code>connect.backoff.initial.delay.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the initial delay when trying to reconnect to a primary after the first failed connection attempt or when no primary is available. Defaults to 1 second (1000 ms).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-connect-backoff-max-delay-ms"></a><a href="#mongodb-property-connect-backoff-max-delay-ms"><code>connect.backoff.max.delay.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum delay when trying to reconnect to a primary after repeated failed connection attempts or when no primary is available. Defaults to 120 seconds (120,000 ms).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-connect-max-attempts"></a><a href="#mongodb-property-connect-max-attempts"><code>connect.max.attempts</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>16</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum number of failed connection attempts to a replica set primary before an exception occurs and task is aborted. Defaults to 16, which with the defaults for <code>connect.backoff.initial.delay.ms</code> and <code>connect.backoff.max.delay.ms</code> results in just over 20 minutes of attempts before failing.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-mongodb-members-auto-discover"></a><a href="#mongodb-property-mongodb-members-auto-discover"><code>mongodb.members.auto.discover</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Boolean value that specifies whether the addresses in 'mongodb.hosts' are seeds that should be used to discover all members of the cluster or replica set (<code>true</code>), or whether the address(es) in <code>mongodb.hosts</code> should be used as is (<code>false</code>). The default is <code>true</code> and should be used in all cases except where MongoDB is <a href="#mongodb-replicaset">fronted by a proxy</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-source-struct-version"></a><a href="#mongodb-property-source-struct-version"><code>source.struct.version</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>v2</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Schema version for the <code>source</code> block in CDC events. Debezium 0.10 introduced a few breaking<br>
changes to the structure of the <code>source</code> block in order to unify the exposed structure across
all the connectors.<br>
By setting this option to <code>v1</code> the structure used in earlier versions can be produced.
Note that this setting is not recommended and is planned for removal in a future Debezium version.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-heartbeat-interval-ms"></a><a href="#mongodb-property-heartbeat-interval-ms"><code>heartbeat.interval.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>0</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls how frequently heartbeat messages are sent.<br>
This property contains an interval in milli-seconds that defines how frequently the connector sends messages into a heartbeat topic.
This can be used to monitor whether the connector is still receiving change events from the database.
You also should leverage heartbeat messages in cases where only records in non-captured collections are changed for a longer period of time.
In such situation the connector would proceed to read the oplog from the database but never emit any change messages into Kafka,
which in turn means that no offset updates are committed to Kafka.
This will cause the oplog files to be rotated out but connector will not notice it so on restart some events are no longer available which leads to the need of re-execution of the initial snapshot.</p>
</div>
<div class="paragraph">
<p>Set this parameter to <code>0</code> to not send heartbeat messages at all.<br>
Disabled by default.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-heartbeat-topics-prefix"></a><a href="#mongodb-property-heartbeat-topics-prefix"><code>heartbeat.topics.prefix</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>__debezium-heartbeat</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls the naming of the topic to which heartbeat messages are sent.<br>
The topic is named according to the pattern <code>&lt;heartbeat.topics.prefix&gt;.&lt;server.name&gt;</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-sanitize-field-names"></a><a href="#mongodb-property-sanitize-field-names"><code>sanitize.field.names</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code> when connector configuration explicitly specifies the <code>key.converter</code> or <code>value.converter</code> parameters to use Avro, otherwise defaults to <code>false</code>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether field names are sanitized to adhere to Avro naming requirements.
See <a href="../configuration/avro.html#avro-naming" class="page">Avro naming</a> for more details.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-skipped-operations"></a><a href="#mongodb-property-skipped-operations"><code>skipped.operations</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>comma-separated list of oplog operations that will be skipped during streaming.
The operations include: <code>i</code> for inserts, <code>u</code> for updates, and <code>d</code> for deletes.
By default, no operations are skipped.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="mongodb-property-provide-transaction-metadata"></a><a href="#mongodb-property-provide-transaction-metadata"><code>provide.transaction.metadata</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to <code>true</code> Debezium generates events with transaction boundaries and enriches data events envelope with transaction metadata.</p>
</div>
<div class="paragraph">
<p>See <a href="#mongodb-transaction-metadata">Transaction Metadata</a> for additional details.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mongodb-when-things-go-wrong"><a class="anchor" href="#mongodb-when-things-go-wrong"></a>MongoDB connector common issues</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Debezium is a distributed system that captures all changes in multiple upstream databases, and will never miss or lose an event. Of course, when the system is operating nominally or being administered carefully, then Debezium provides <em>exactly once</em> delivery of every change event. However, if a fault does happen then the system will still not lose any events, although while it is recovering from the fault it may repeat some change events. Thus, in these abnormal situations Debezium (like Kafka) provides <em>at least once</em> delivery of change events.</p>
</div>
<div class="paragraph">
<p>The rest of this section describes how Debezium handles various kinds of faults and problems.</p>
</div>
<div class="sect2">
<h3 id="_configuration_and_startup_errors"><a class="anchor" href="#_configuration_and_startup_errors"></a>Configuration and startup errors</h3>
<div class="paragraph">
<p>The connector will fail upon startup, report an error/exception in the log, and stop running when the connector&#8217;s configuration is invalid, or when the connector repeatedly fails to connect to MongoDB using the specified connectivity parameters. Reconnection is done using exponential backoff, and the maximum number of attempts is configurable.</p>
</div>
<div class="paragraph">
<p>In these cases, the error will have more details about the problem and possibly a suggested work around. The connector can be restarted when the configuration has been corrected or the MongoDB problem has been addressed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mongodb_becomes_unavailable"><a class="anchor" href="#_mongodb_becomes_unavailable"></a>MongoDB becomes unavailable</h3>
<div class="paragraph">
<p>Once the connector is running, if the primary node of any of the MongoDB replica sets become unavailable or unreachable, the connector will repeatedly attempt to reconnect to the primary node, using exponential backoff to prevent saturating the network or servers. If the primary remains unavailable after the configurable number of connection attempts, the connector will fail.</p>
</div>
<div class="paragraph">
<p>The attempts to reconnect are controlled by three properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connect.backoff.initial.delay.ms</code> - The delay before attempting to reconnect for the first time, with a default of 1 second (1000 milliseconds).</p>
</li>
<li>
<p><code>connect.backoff.max.delay.ms</code> - The maximum delay before attempting to reconnect, with a default of 120 seconds (120,000 milliseconds).</p>
</li>
<li>
<p><code>connect.max.attempts</code> - The maximum number of attempts before an error is produced, with a default of 16.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each delay is double that of the prior delay, up to the maximum delay. Given the default values, the following table shows the delay for each failed connection attempt and the total accumulated time before failure.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 40%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Reconnection attempt number</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Delay before attempt, in seconds</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Total delay before attempt, in minutes and seconds</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>1</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>1</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>00:01</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>00:03</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>3</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>4</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>00:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>4</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>00:15</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>5</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>16</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>00:31</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>6</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>32</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>01:03</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>7</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>64</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>02:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>04:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>9</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>06:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>10</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>08:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>11</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>10:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>12</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>12:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>13</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>14:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>14</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>16:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>15</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>18:07</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>16</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>120</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>20:07</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_kafka_connect_process_stops_gracefully"><a class="anchor" href="#_kafka_connect_process_stops_gracefully"></a>Kafka Connect process stops gracefully</h3>
<div class="paragraph">
<p>If Kafka Connect is being run in distributed mode, and a Kafka Connect process is stopped gracefully, then prior to shutdown of that processes Kafka Connect will migrate all of the process' connector tasks to another Kafka Connect process in that group, and the new connector tasks will pick up exactly where the prior tasks left off.
There is a short delay in processing while the connector tasks are stopped gracefully and restarted on the new processes.</p>
</div>
<div class="paragraph">
<p>If the group contains only one process and that process is stopped gracefully, then Kafka Connect will stop the connector and record the last offset for each replica set. Upon restart, the replica set tasks will continue exactly where they left off.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kafka_connect_process_crashes"><a class="anchor" href="#_kafka_connect_process_crashes"></a>Kafka Connect process crashes</h3>
<div class="paragraph">
<p>If the Kafka Connector process stops unexpectedly, then any connector tasks it was running will terminate without recording their most recently-processed offsets.
When Kafka Connect is being run in distributed mode, it will restart those connector tasks on other processes.
However, the MongoDB connectors will resume from the last offset <em>recorded</em> by the earlier processes, which means that the new replacement tasks may generate some of the same change events that were processed just prior to the crash.
The number of duplicate events depends on the offset flush period and the volume of data changes just before the crash.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because there is a chance that some events may be duplicated during a recovery from failure, consumers should always anticipate some events may be duplicated. Debezium changes are idempotent, so a sequence of events always results in the same state.</p>
</div>
<div class="paragraph">
<p>Debezium also includes with each change event message the source-specific information about the origin of the event, including the MongoDB event&#8217;s unique transaction identifier (<code>h</code>) and timestamp (<code>sec</code> and <code>ord</code>). Consumers can keep track of other of these values to know whether it has already seen a particular event.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_kafka_becomes_unavailable"><a class="anchor" href="#_kafka_becomes_unavailable"></a>Kafka becomes unavailable</h3>
<div class="paragraph">
<p>As the connector generates change events, the Kafka Connect framework records those events in Kafka using the Kafka producer API. Kafka Connect will also periodically record the latest offset that appears in those change events, at a frequency that you have specified in the Kafka Connect worker configuration. If the Kafka brokers become unavailable, the Kafka Connect worker process running the connectors will simply repeatedly attempt to reconnect to the Kafka brokers. In other words, the connector tasks will simply pause until a connection can be reestablished, at which point the connectors will resume exactly where they left off.</p>
</div>
</div>
<div class="sect2">
<h3 id="_connector_is_stopped_for_a_duration"><a class="anchor" href="#_connector_is_stopped_for_a_duration"></a>Connector is stopped for a duration</h3>
<div class="paragraph">
<p>If the connector is gracefully stopped, the replica sets can continue to be used and any new changes are recorded in MongoDB&#8217;s oplog.
When the connector is restarted, it will resume streaming changes for each replica set where it last left off, recording change events for all of the changes that were made while the connector was stopped. If the connector is stopped long enough such that MongoDB purges from its oplog some operations that the connector has not read, then upon startup the connector will perform a snapshot.</p>
</div>
<div class="paragraph">
<p>A properly configured Kafka cluster is capable of massive throughput.
Kafka Connect is written with Kafka best practices, and given enough resources will also be able to handle very large numbers of database change events. Because of this, when a connector has been restarted after a while, it is very likely to catch up with the database, though how quickly will depend upon the capabilities and performance of Kafka and the volume of changes being made to the data in MongoDB.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the connector remains stopped for long enough, MongoDB might purge older oplog files and the connector&#8217;s last position may be lost.
In this case, when the connector configured with <em>initial</em> snapshot mode (the default) is finally restarted, the MongoDB server will no longer have the starting point and the connector will fail with an error.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mongodb_loses_writes"><a class="anchor" href="#_mongodb_loses_writes"></a>MongoDB loses writes</h3>
<div class="paragraph">
<p>It is possible for MongoDB to lose commits in specific failure situations. For example, if the primary applies a change and records it in its oplog before it then crashes unexpectedly, the secondary nodes may not have had a chance to read those changes from the primary&#8217;s oplog before the primary crashed. If one such secondary is then elected as primary, its oplog is missing the last changes that the old primary had recorded and no longer has those changes.</p>
</div>
<div class="paragraph">
<p>In these cases where MongoDB loses changes recorded in a primary&#8217;s oplog, it is possible that the MongoDB connector may or may not capture these lost changes. At this time, there is no way to prevent this side effect of MongoDB.</p>
</div>
</div>
</div>
</div>
</article>
</div>
<div class="article-cell2">
</div>
</div>

<div id="toc-rightbar"></div>    <footer class="footer">
        <div class="wrapper">
            <div class="copyright">Copyright &copy; 2021 Debezium Community</div>
        </div>
    </footer>
</main>
</div>
<script>
    /* Make sure TOC carets are expanded if sub-elements exist */
    $("#toc").each(function(i,v) {
      $(this).closest('article').addClass('with-toc');
    });

    $("#toc ul.sectlevel1 > li").each(function(i,v) {
      $(this).has("ul").addClass("expanded");
    });

    $(function() {
        /* Expands all the documentation submenus */
        $(".nav-list > .nav-item:not(.is-active) .nav-item-toggle").click();
    });

    /**
     * This checks if a "#toc" element exists in the DOM and if so:
     *
     *  1. Appends a cloned copy of the #toc node to the #toc-rightbar div.
     *  2. Forces the #toc-rightbar div to be visible.
     *  3. Adds the .toc-right class to the #article-wrapper div to restrict the article's overall width.
     */
    var $toc = $("#toc");
    if ( $toc.length ) {
        $("#toc-rightbar").append($toc.clone());
        $("body .main").addClass("with-toc");
    }

    /**
     * In order to make CSS changes that are backward compatible with old adoc files, this applies a version
     * style to the body tag so we can use it to differentiate between CSS styles per version if needed,
     * such as tfoot rows.
     */
    var $version = $("body .nav-container").data("version");
    var $versionClass = "version-" + $version;
    $versionClass = $versionClass.replace('.','-');
    $("body").addClass($versionClass);

    /** A CSS trick to wrap long-width tables in a div that can be scrolled on smaller screens */
    $("table.tableblock").wrap("<div class='table-scroll-wrapper'></div>");

    $(function() {
        /* apply floating scrollbar to the scroll-wrapper */
        $(".table-scroll-wrapper").floatingScrollbar();
    });

</script>
<script src="../../../debezium-antora/js/site.js"></script>
<script async src="../../../debezium-antora/js/vendor/highlight.js"></script>

<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-10656779-1");
    pageTracker._trackPageview();
  } catch(err) {}
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76464546-1', 'auto');
  ga('send', 'pageview');
  ga('set', 'anonymizeIp', true);
  ga('require', 'linkid', 'linkid.js');
</script>
</body>
</html>